package com.ict.java02;



public class Ex01 {
	/*
 문제 1.  클래스는 무엇들로 이루어 졌는가 (3가지 쓰시오) ?
     답 > 멤버필드, 생성자, 멤버메소드
     
    - 멤버필드(변수와 상수) : 데이터(값) 
      변수 : 언제든지 변할 수 있는 데이터
      상수 : 한번 저장되면 변경할 수 없는 데이터
   예)  private String name ;
		private int math ;
		private int sum ;
		private double avg ;
		private String hak ;
		
	- 생성자(객체 만들때 쓰는 것) : 클래스를 객체로 만들 때 반드시 호출해야 되는 것
	  생성자의 목적 : 멤버필드의 초기값을 지정하는 것이 목적
	  생성자의 특징 : 클래스와 같은 이름을 사용한다.
	  				  반환형이 없는 메소드와 같다.
	  				  
	-> 한 클래스에서 생성자를 여러개 가질 수 있다. (생성자 오버로드) >라고 부름
	-> 인자가 없는 생성자를 기본 생성자라고 한다.
	-> 만약에 생성자를 만들지 않으면 해당 클래스를 객체로 만들때
	   기본 생성자를 사용해야 된다.
	   그런데 생성자(class 단어가 안붙었으면서 클래스 이름과 같은 거)가 존재하면 존재하는 생성자로 만들어야 한다.
	-> 생성자를 객체로 만드는 방법
	   클래스이름 참조변수 = new 생성자
	   
	   예) public VO() {} (> ()안에 인자가 없으니 얘는 기본 생성자다.)
	

		public VO(String name, int age, double weight, boolean gender) { (>여긴 인자가 있음.)
		super();
		this.name = name;
		this.age = age;
		this.weight = weight;
		this.gender = gender;
	   
    - 멤버메소드 : 기능, 동작, 하는 것, 작동 
    	-> 메소드를 호출하면 어떠한 내용을 실행(동작)한다.
    	-> 한 클래스에서 같은 이름의 여러 메소드를 오버로드 라고 한다.
    	-> 반환형 : 어떠한 행동을 한 후 반드시 자기를 호출한 곳으로 되돌아 간다.
    				내용을 가지고 가면 반환형이 있다. 
    				그 가지고 가는 내용의 자료형을 반환형이라고 한다.
    				예)	public int getAge() {
							return age; } -> 여기서 age의 반환형은 int라는 자료형을 가지고 가는 것.
					만약에 내용을 가지고 가지 않으면 반환형이 없는 것이다.
					이렇게 반환형이 없으면 void 라고 쓴다.
					예) public void setName(String name) {
							this.name = name; } -> 얘는 자료형 없어서 void써 있음 그래서 반환형이 없음., 
							그래서 생성자고 생성자니까 클래스이름을 씀.
		
		-> getter() : 메소드를 호출한 곳에서 무언가를 얻어 낼 때 사용 > 게터 메소드임.
		 		예) public void setAge(int age) {
				this.age = age; // 외부에서 뭔가를 받아서 바꾸는 것(변경시키는 것)
						}
		-> setter() : 메소드를 이용해서 멤버 변수의 데이터를 변경할 때 사용
				예_ public double getWeight() {
				return weight; // 있는걸 보내고 뭔가를 받지 않음. 
				
 문제 2. 클래스를 객체로 생성할 때 초기화를 목적으로 반드시 호출하는 것을 무엇인가 ?
	답> 생성자
	참고* 생성자의 특징 : 클래스와 같은 이름을 사용한다.
	  				  	  반환형이 없는 메소드와 같다.
	  				  	  
 문제 3. 어떤 클래스에서 같은이름의 메소드가 여러개 존재하는 것으로 반드시 매개변수는 달라야 하는것을 무엇이라 하는가? 
    답> 오버로딩 (오버로드)
	
	- 이름이 같은데 오류가 나지 않는 이유 : 인자의 종류나 인자의 갯수가 다르면 이름이 같아도 오류가 나지 않음(매개변수(인자)는 달라야 하는것 과 같은말)
	예 ) public VO() {}
		public VO(String name, int age, double weight, boolean gender) { -> 이 둘처럼!
		
 문제 4. 상속관계에서 부모클래스의 메소드를 자식클래스가 가져와서 자식클래스 상황에 맞게 변경하는 것을 무엇이라 하는가?
 	답> 오버라이딩
 	
 	- 상속 : 클래스와 클래스와의 관계를 말하는데
 		  부모클래스 : super
 		  자식클래스 : sub
 		  자식클래스가 부모클래스의 멤버필드와 멤버메소드 객체 생성 없이
 		  마음대로 사용 할 수 있도록 관계를 만드는 것 (부모는 자식꺼 못 씀. 쓰려면 자식을 객체로 만들어서 써야함)
 		  (객체로 안 만들고 굳이 상속해서 쓰는 이유는 코딩이 간결해져서임.)
 		  
 	- 오버라이딩 : 자식클래스가 부모클래스의 메소드를 가지고 와서 변경해서 사용
 
 	final 클래스(파이널이 붙어있는 클래스) : 상속을 못하게 한다. (자식클래스를 못 만든다.)
 	final 메소드 : 오버라이딩을 못하게 한다. (부모꺼 그대로만을 쓸 수 있고 만들어서는 못쓰는 것)
 	final 변수	 : 상수 (가 됨. 그래서 데이터 변경을 못하게 한다.) 
 	
 문제 5. 추상클래스와 인터페이스에 대해서 쓰시오.
 	- 추상 클래스 : 추상메소드를 한 개 이상 가지고 있는 클래스
 	  추상 메소드 : 메소드의 내용(몸통 = body)가 존재하지 않은 메소드
 	 
 	  일반메소드 : public 반환형 이름([인자]) {실행할 내용};  -> '{실행할 내용}' 이게 몸통임.
 	  추상메소드 : public 반환형 이름([인자]) ;
 	  
   * 추상메소드나 추상클래스이면 무조건 abstract 예약어를 사용해야 한다.
 		예)
 	 // 추상클래스	
 	 public abstract class Unit {
		    // 추상메소드 
			public abstract void decEnergy(); > 지금 여기 실행할 내용 몸통 없음.
		}
		
 중요 ** 추상클래스를 상속받은 일반 클래스는 무조건 추상메소드를 오버라이딩 해야한다.
	예)
	 public class Protoss extends Unit{  > 프로토스는 일반클래스라서 유닛이라는 클래스를 상속 받으니까 오버라이딩해야함 아래처럼 
	 
	    @Override
		public abstract void decEnergy(){ 여기 내용
		 내용  생김 ~
			}	
		}
		
		추상클래스 에서는 abstract 안쓰면 오류나는데 인터페이스는 앱스트랙트 안써도 상관없음.
	
	- 인터페이스 : 상수와 추상메소드로 이루어졌다.
				 객체 생성 할 수 없다.
				 interface 예약어를 사용한다.
		예)
		public interface Ex01 {	 
			상수와 추상메소드	
			// 아래꺼 추상메소드 임
			public abstract void play();
	
		// interface 에서는 abstract 예약어를 사용하지 않아도 오류가 아니다. 바로아래꺼 보면 됨.
		  public void sound();
		}
	** 인터페이스를 상속받은 일반 클래스는 무조건 추상메소드를 오버라이딩 해야된다. 아래가 예시임.
	  예)
		public Ex02 implements Ex01{
		 @Override
		 public void play() {
		 
		 }
		 @Override
		public void sound(){
		
		}
	
	}
 */
			 
}
